/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package to.unified.unified_java_sdk.models.operations;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Optional;
import to.unified.unified_java_sdk.utils.SpeakeasyMetadata;
import to.unified.unified_java_sdk.utils.Utils;


public class ListMessagingMessagesRequest {
    /**
     * The channel ID to filter by. You can also use these aliases; INBOX, SENT or DRAFT (reference to
     * MessagingChannel)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=channel_id")
    private Optional<String> channelId;

    /**
     * ID of the connection
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=connection_id")
    private String connectionId;

    /**
     * The end date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=end_lt")
    private Optional<String> endLt;

    /**
     * Whether to flatten grouped or recurring items into individual entries.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=expand")
    private Optional<Boolean> expand;

    /**
     * Fields to return
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=fields")
    private Optional<? extends List<ListMessagingMessagesQueryParamFields>> fields;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=limit")
    private Optional<Double> limit;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=offset")
    private Optional<Double> offset;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=order")
    private Optional<String> order;

    /**
     * The parent ID to filter by
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=parent_id")
    private Optional<String> parentId;

    /**
     * Query string to search. eg. email address or name
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=query")
    private Optional<String> query;

    /**
     * Raw parameters to include in the 3rd-party request. Encoded as a URL component. eg.
     * 
     * <p>raw parameters: foo=bar&amp;zoo=bar -&gt; raw=foo%3Dbar%26zoo%3Dbar
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=raw")
    private Optional<String> raw;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=sort")
    private Optional<String> sort;

    /**
     * The start date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=start_gte")
    private Optional<String> startGte;


    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=type")
    private Optional<String> type;

    /**
     * Return only results whose updated date is equal or greater to this value (ISO-8601 /
     * YYYY-MM-DDTHH:MM:SSZ format)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=updated_gte")
    private Optional<String> updatedGte;

    /**
     * The user/employee ID to filter by (reference to HrisEmployee)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=user_id")
    private Optional<String> userId;

    /**
     * The user/employee ID to filter by
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=user_mentioned_id")
    private Optional<String> userMentionedId;

    @JsonCreator
    public ListMessagingMessagesRequest(
            Optional<String> channelId,
            String connectionId,
            Optional<String> endLt,
            Optional<Boolean> expand,
            Optional<? extends List<ListMessagingMessagesQueryParamFields>> fields,
            Optional<Double> limit,
            Optional<Double> offset,
            Optional<String> order,
            Optional<String> parentId,
            Optional<String> query,
            Optional<String> raw,
            Optional<String> sort,
            Optional<String> startGte,
            Optional<String> type,
            Optional<String> updatedGte,
            Optional<String> userId,
            Optional<String> userMentionedId) {
        Utils.checkNotNull(channelId, "channelId");
        Utils.checkNotNull(connectionId, "connectionId");
        Utils.checkNotNull(endLt, "endLt");
        Utils.checkNotNull(expand, "expand");
        Utils.checkNotNull(fields, "fields");
        Utils.checkNotNull(limit, "limit");
        Utils.checkNotNull(offset, "offset");
        Utils.checkNotNull(order, "order");
        Utils.checkNotNull(parentId, "parentId");
        Utils.checkNotNull(query, "query");
        Utils.checkNotNull(raw, "raw");
        Utils.checkNotNull(sort, "sort");
        Utils.checkNotNull(startGte, "startGte");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(updatedGte, "updatedGte");
        Utils.checkNotNull(userId, "userId");
        Utils.checkNotNull(userMentionedId, "userMentionedId");
        this.channelId = channelId;
        this.connectionId = connectionId;
        this.endLt = endLt;
        this.expand = expand;
        this.fields = fields;
        this.limit = limit;
        this.offset = offset;
        this.order = order;
        this.parentId = parentId;
        this.query = query;
        this.raw = raw;
        this.sort = sort;
        this.startGte = startGte;
        this.type = type;
        this.updatedGte = updatedGte;
        this.userId = userId;
        this.userMentionedId = userMentionedId;
    }
    
    public ListMessagingMessagesRequest(
            String connectionId) {
        this(Optional.empty(), connectionId, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty());
    }

    /**
     * The channel ID to filter by. You can also use these aliases; INBOX, SENT or DRAFT (reference to
     * MessagingChannel)
     */
    @JsonIgnore
    public Optional<String> channelId() {
        return channelId;
    }

    /**
     * ID of the connection
     */
    @JsonIgnore
    public String connectionId() {
        return connectionId;
    }

    /**
     * The end date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    @JsonIgnore
    public Optional<String> endLt() {
        return endLt;
    }

    /**
     * Whether to flatten grouped or recurring items into individual entries.
     */
    @JsonIgnore
    public Optional<Boolean> expand() {
        return expand;
    }

    /**
     * Fields to return
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<ListMessagingMessagesQueryParamFields>> fields() {
        return (Optional<List<ListMessagingMessagesQueryParamFields>>) fields;
    }

    @JsonIgnore
    public Optional<Double> limit() {
        return limit;
    }

    @JsonIgnore
    public Optional<Double> offset() {
        return offset;
    }

    @JsonIgnore
    public Optional<String> order() {
        return order;
    }

    /**
     * The parent ID to filter by
     */
    @JsonIgnore
    public Optional<String> parentId() {
        return parentId;
    }

    /**
     * Query string to search. eg. email address or name
     */
    @JsonIgnore
    public Optional<String> query() {
        return query;
    }

    /**
     * Raw parameters to include in the 3rd-party request. Encoded as a URL component. eg.
     * 
     * <p>raw parameters: foo=bar&amp;zoo=bar -&gt; raw=foo%3Dbar%26zoo%3Dbar
     */
    @JsonIgnore
    public Optional<String> raw() {
        return raw;
    }

    @JsonIgnore
    public Optional<String> sort() {
        return sort;
    }

    /**
     * The start date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    @JsonIgnore
    public Optional<String> startGte() {
        return startGte;
    }

    @JsonIgnore
    public Optional<String> type() {
        return type;
    }

    /**
     * Return only results whose updated date is equal or greater to this value (ISO-8601 /
     * YYYY-MM-DDTHH:MM:SSZ format)
     */
    @JsonIgnore
    public Optional<String> updatedGte() {
        return updatedGte;
    }

    /**
     * The user/employee ID to filter by (reference to HrisEmployee)
     */
    @JsonIgnore
    public Optional<String> userId() {
        return userId;
    }

    /**
     * The user/employee ID to filter by
     */
    @JsonIgnore
    public Optional<String> userMentionedId() {
        return userMentionedId;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The channel ID to filter by. You can also use these aliases; INBOX, SENT or DRAFT (reference to
     * MessagingChannel)
     */
    public ListMessagingMessagesRequest withChannelId(String channelId) {
        Utils.checkNotNull(channelId, "channelId");
        this.channelId = Optional.ofNullable(channelId);
        return this;
    }


    /**
     * The channel ID to filter by. You can also use these aliases; INBOX, SENT or DRAFT (reference to
     * MessagingChannel)
     */
    public ListMessagingMessagesRequest withChannelId(Optional<String> channelId) {
        Utils.checkNotNull(channelId, "channelId");
        this.channelId = channelId;
        return this;
    }

    /**
     * ID of the connection
     */
    public ListMessagingMessagesRequest withConnectionId(String connectionId) {
        Utils.checkNotNull(connectionId, "connectionId");
        this.connectionId = connectionId;
        return this;
    }

    /**
     * The end date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    public ListMessagingMessagesRequest withEndLt(String endLt) {
        Utils.checkNotNull(endLt, "endLt");
        this.endLt = Optional.ofNullable(endLt);
        return this;
    }


    /**
     * The end date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    public ListMessagingMessagesRequest withEndLt(Optional<String> endLt) {
        Utils.checkNotNull(endLt, "endLt");
        this.endLt = endLt;
        return this;
    }

    /**
     * Whether to flatten grouped or recurring items into individual entries.
     */
    public ListMessagingMessagesRequest withExpand(boolean expand) {
        Utils.checkNotNull(expand, "expand");
        this.expand = Optional.ofNullable(expand);
        return this;
    }


    /**
     * Whether to flatten grouped or recurring items into individual entries.
     */
    public ListMessagingMessagesRequest withExpand(Optional<Boolean> expand) {
        Utils.checkNotNull(expand, "expand");
        this.expand = expand;
        return this;
    }

    /**
     * Fields to return
     */
    public ListMessagingMessagesRequest withFields(List<ListMessagingMessagesQueryParamFields> fields) {
        Utils.checkNotNull(fields, "fields");
        this.fields = Optional.ofNullable(fields);
        return this;
    }


    /**
     * Fields to return
     */
    public ListMessagingMessagesRequest withFields(Optional<? extends List<ListMessagingMessagesQueryParamFields>> fields) {
        Utils.checkNotNull(fields, "fields");
        this.fields = fields;
        return this;
    }

    public ListMessagingMessagesRequest withLimit(double limit) {
        Utils.checkNotNull(limit, "limit");
        this.limit = Optional.ofNullable(limit);
        return this;
    }


    public ListMessagingMessagesRequest withLimit(Optional<Double> limit) {
        Utils.checkNotNull(limit, "limit");
        this.limit = limit;
        return this;
    }

    public ListMessagingMessagesRequest withOffset(double offset) {
        Utils.checkNotNull(offset, "offset");
        this.offset = Optional.ofNullable(offset);
        return this;
    }


    public ListMessagingMessagesRequest withOffset(Optional<Double> offset) {
        Utils.checkNotNull(offset, "offset");
        this.offset = offset;
        return this;
    }

    public ListMessagingMessagesRequest withOrder(String order) {
        Utils.checkNotNull(order, "order");
        this.order = Optional.ofNullable(order);
        return this;
    }


    public ListMessagingMessagesRequest withOrder(Optional<String> order) {
        Utils.checkNotNull(order, "order");
        this.order = order;
        return this;
    }

    /**
     * The parent ID to filter by
     */
    public ListMessagingMessagesRequest withParentId(String parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = Optional.ofNullable(parentId);
        return this;
    }


    /**
     * The parent ID to filter by
     */
    public ListMessagingMessagesRequest withParentId(Optional<String> parentId) {
        Utils.checkNotNull(parentId, "parentId");
        this.parentId = parentId;
        return this;
    }

    /**
     * Query string to search. eg. email address or name
     */
    public ListMessagingMessagesRequest withQuery(String query) {
        Utils.checkNotNull(query, "query");
        this.query = Optional.ofNullable(query);
        return this;
    }


    /**
     * Query string to search. eg. email address or name
     */
    public ListMessagingMessagesRequest withQuery(Optional<String> query) {
        Utils.checkNotNull(query, "query");
        this.query = query;
        return this;
    }

    /**
     * Raw parameters to include in the 3rd-party request. Encoded as a URL component. eg.
     * 
     * <p>raw parameters: foo=bar&amp;zoo=bar -&gt; raw=foo%3Dbar%26zoo%3Dbar
     */
    public ListMessagingMessagesRequest withRaw(String raw) {
        Utils.checkNotNull(raw, "raw");
        this.raw = Optional.ofNullable(raw);
        return this;
    }


    /**
     * Raw parameters to include in the 3rd-party request. Encoded as a URL component. eg.
     * 
     * <p>raw parameters: foo=bar&amp;zoo=bar -&gt; raw=foo%3Dbar%26zoo%3Dbar
     */
    public ListMessagingMessagesRequest withRaw(Optional<String> raw) {
        Utils.checkNotNull(raw, "raw");
        this.raw = raw;
        return this;
    }

    public ListMessagingMessagesRequest withSort(String sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = Optional.ofNullable(sort);
        return this;
    }


    public ListMessagingMessagesRequest withSort(Optional<String> sort) {
        Utils.checkNotNull(sort, "sort");
        this.sort = sort;
        return this;
    }

    /**
     * The start date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    public ListMessagingMessagesRequest withStartGte(String startGte) {
        Utils.checkNotNull(startGte, "startGte");
        this.startGte = Optional.ofNullable(startGte);
        return this;
    }


    /**
     * The start date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
     */
    public ListMessagingMessagesRequest withStartGte(Optional<String> startGte) {
        Utils.checkNotNull(startGte, "startGte");
        this.startGte = startGte;
        return this;
    }

    public ListMessagingMessagesRequest withType(String type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }


    public ListMessagingMessagesRequest withType(Optional<String> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * Return only results whose updated date is equal or greater to this value (ISO-8601 /
     * YYYY-MM-DDTHH:MM:SSZ format)
     */
    public ListMessagingMessagesRequest withUpdatedGte(String updatedGte) {
        Utils.checkNotNull(updatedGte, "updatedGte");
        this.updatedGte = Optional.ofNullable(updatedGte);
        return this;
    }


    /**
     * Return only results whose updated date is equal or greater to this value (ISO-8601 /
     * YYYY-MM-DDTHH:MM:SSZ format)
     */
    public ListMessagingMessagesRequest withUpdatedGte(Optional<String> updatedGte) {
        Utils.checkNotNull(updatedGte, "updatedGte");
        this.updatedGte = updatedGte;
        return this;
    }

    /**
     * The user/employee ID to filter by (reference to HrisEmployee)
     */
    public ListMessagingMessagesRequest withUserId(String userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = Optional.ofNullable(userId);
        return this;
    }


    /**
     * The user/employee ID to filter by (reference to HrisEmployee)
     */
    public ListMessagingMessagesRequest withUserId(Optional<String> userId) {
        Utils.checkNotNull(userId, "userId");
        this.userId = userId;
        return this;
    }

    /**
     * The user/employee ID to filter by
     */
    public ListMessagingMessagesRequest withUserMentionedId(String userMentionedId) {
        Utils.checkNotNull(userMentionedId, "userMentionedId");
        this.userMentionedId = Optional.ofNullable(userMentionedId);
        return this;
    }


    /**
     * The user/employee ID to filter by
     */
    public ListMessagingMessagesRequest withUserMentionedId(Optional<String> userMentionedId) {
        Utils.checkNotNull(userMentionedId, "userMentionedId");
        this.userMentionedId = userMentionedId;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ListMessagingMessagesRequest other = (ListMessagingMessagesRequest) o;
        return 
            Utils.enhancedDeepEquals(this.channelId, other.channelId) &&
            Utils.enhancedDeepEquals(this.connectionId, other.connectionId) &&
            Utils.enhancedDeepEquals(this.endLt, other.endLt) &&
            Utils.enhancedDeepEquals(this.expand, other.expand) &&
            Utils.enhancedDeepEquals(this.fields, other.fields) &&
            Utils.enhancedDeepEquals(this.limit, other.limit) &&
            Utils.enhancedDeepEquals(this.offset, other.offset) &&
            Utils.enhancedDeepEquals(this.order, other.order) &&
            Utils.enhancedDeepEquals(this.parentId, other.parentId) &&
            Utils.enhancedDeepEquals(this.query, other.query) &&
            Utils.enhancedDeepEquals(this.raw, other.raw) &&
            Utils.enhancedDeepEquals(this.sort, other.sort) &&
            Utils.enhancedDeepEquals(this.startGte, other.startGte) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.updatedGte, other.updatedGte) &&
            Utils.enhancedDeepEquals(this.userId, other.userId) &&
            Utils.enhancedDeepEquals(this.userMentionedId, other.userMentionedId);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            channelId, connectionId, endLt,
            expand, fields, limit,
            offset, order, parentId,
            query, raw, sort,
            startGte, type, updatedGte,
            userId, userMentionedId);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ListMessagingMessagesRequest.class,
                "channelId", channelId,
                "connectionId", connectionId,
                "endLt", endLt,
                "expand", expand,
                "fields", fields,
                "limit", limit,
                "offset", offset,
                "order", order,
                "parentId", parentId,
                "query", query,
                "raw", raw,
                "sort", sort,
                "startGte", startGte,
                "type", type,
                "updatedGte", updatedGte,
                "userId", userId,
                "userMentionedId", userMentionedId);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> channelId = Optional.empty();

        private String connectionId;

        private Optional<String> endLt = Optional.empty();

        private Optional<Boolean> expand = Optional.empty();

        private Optional<? extends List<ListMessagingMessagesQueryParamFields>> fields = Optional.empty();

        private Optional<Double> limit = Optional.empty();

        private Optional<Double> offset = Optional.empty();

        private Optional<String> order = Optional.empty();

        private Optional<String> parentId = Optional.empty();

        private Optional<String> query = Optional.empty();

        private Optional<String> raw = Optional.empty();

        private Optional<String> sort = Optional.empty();

        private Optional<String> startGte = Optional.empty();

        private Optional<String> type = Optional.empty();

        private Optional<String> updatedGte = Optional.empty();

        private Optional<String> userId = Optional.empty();

        private Optional<String> userMentionedId = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The channel ID to filter by. You can also use these aliases; INBOX, SENT or DRAFT (reference to
         * MessagingChannel)
         */
        public Builder channelId(String channelId) {
            Utils.checkNotNull(channelId, "channelId");
            this.channelId = Optional.ofNullable(channelId);
            return this;
        }

        /**
         * The channel ID to filter by. You can also use these aliases; INBOX, SENT or DRAFT (reference to
         * MessagingChannel)
         */
        public Builder channelId(Optional<String> channelId) {
            Utils.checkNotNull(channelId, "channelId");
            this.channelId = channelId;
            return this;
        }


        /**
         * ID of the connection
         */
        public Builder connectionId(String connectionId) {
            Utils.checkNotNull(connectionId, "connectionId");
            this.connectionId = connectionId;
            return this;
        }


        /**
         * The end date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
         */
        public Builder endLt(String endLt) {
            Utils.checkNotNull(endLt, "endLt");
            this.endLt = Optional.ofNullable(endLt);
            return this;
        }

        /**
         * The end date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
         */
        public Builder endLt(Optional<String> endLt) {
            Utils.checkNotNull(endLt, "endLt");
            this.endLt = endLt;
            return this;
        }


        /**
         * Whether to flatten grouped or recurring items into individual entries.
         */
        public Builder expand(boolean expand) {
            Utils.checkNotNull(expand, "expand");
            this.expand = Optional.ofNullable(expand);
            return this;
        }

        /**
         * Whether to flatten grouped or recurring items into individual entries.
         */
        public Builder expand(Optional<Boolean> expand) {
            Utils.checkNotNull(expand, "expand");
            this.expand = expand;
            return this;
        }


        /**
         * Fields to return
         */
        public Builder fields(List<ListMessagingMessagesQueryParamFields> fields) {
            Utils.checkNotNull(fields, "fields");
            this.fields = Optional.ofNullable(fields);
            return this;
        }

        /**
         * Fields to return
         */
        public Builder fields(Optional<? extends List<ListMessagingMessagesQueryParamFields>> fields) {
            Utils.checkNotNull(fields, "fields");
            this.fields = fields;
            return this;
        }


        public Builder limit(double limit) {
            Utils.checkNotNull(limit, "limit");
            this.limit = Optional.ofNullable(limit);
            return this;
        }

        public Builder limit(Optional<Double> limit) {
            Utils.checkNotNull(limit, "limit");
            this.limit = limit;
            return this;
        }


        public Builder offset(double offset) {
            Utils.checkNotNull(offset, "offset");
            this.offset = Optional.ofNullable(offset);
            return this;
        }

        public Builder offset(Optional<Double> offset) {
            Utils.checkNotNull(offset, "offset");
            this.offset = offset;
            return this;
        }


        public Builder order(String order) {
            Utils.checkNotNull(order, "order");
            this.order = Optional.ofNullable(order);
            return this;
        }

        public Builder order(Optional<String> order) {
            Utils.checkNotNull(order, "order");
            this.order = order;
            return this;
        }


        /**
         * The parent ID to filter by
         */
        public Builder parentId(String parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = Optional.ofNullable(parentId);
            return this;
        }

        /**
         * The parent ID to filter by
         */
        public Builder parentId(Optional<String> parentId) {
            Utils.checkNotNull(parentId, "parentId");
            this.parentId = parentId;
            return this;
        }


        /**
         * Query string to search. eg. email address or name
         */
        public Builder query(String query) {
            Utils.checkNotNull(query, "query");
            this.query = Optional.ofNullable(query);
            return this;
        }

        /**
         * Query string to search. eg. email address or name
         */
        public Builder query(Optional<String> query) {
            Utils.checkNotNull(query, "query");
            this.query = query;
            return this;
        }


        /**
         * Raw parameters to include in the 3rd-party request. Encoded as a URL component. eg.
         * 
         * <p>raw parameters: foo=bar&amp;zoo=bar -&gt; raw=foo%3Dbar%26zoo%3Dbar
         */
        public Builder raw(String raw) {
            Utils.checkNotNull(raw, "raw");
            this.raw = Optional.ofNullable(raw);
            return this;
        }

        /**
         * Raw parameters to include in the 3rd-party request. Encoded as a URL component. eg.
         * 
         * <p>raw parameters: foo=bar&amp;zoo=bar -&gt; raw=foo%3Dbar%26zoo%3Dbar
         */
        public Builder raw(Optional<String> raw) {
            Utils.checkNotNull(raw, "raw");
            this.raw = raw;
            return this;
        }


        public Builder sort(String sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        public Builder sort(Optional<String> sort) {
            Utils.checkNotNull(sort, "sort");
            this.sort = sort;
            return this;
        }


        /**
         * The start date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
         */
        public Builder startGte(String startGte) {
            Utils.checkNotNull(startGte, "startGte");
            this.startGte = Optional.ofNullable(startGte);
            return this;
        }

        /**
         * The start date to filter by (ISO-8601 / YYYY-MM-DDTHH:MM:SSZ format)
         */
        public Builder startGte(Optional<String> startGte) {
            Utils.checkNotNull(startGte, "startGte");
            this.startGte = startGte;
            return this;
        }


        public Builder type(String type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        public Builder type(Optional<String> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        /**
         * Return only results whose updated date is equal or greater to this value (ISO-8601 /
         * YYYY-MM-DDTHH:MM:SSZ format)
         */
        public Builder updatedGte(String updatedGte) {
            Utils.checkNotNull(updatedGte, "updatedGte");
            this.updatedGte = Optional.ofNullable(updatedGte);
            return this;
        }

        /**
         * Return only results whose updated date is equal or greater to this value (ISO-8601 /
         * YYYY-MM-DDTHH:MM:SSZ format)
         */
        public Builder updatedGte(Optional<String> updatedGte) {
            Utils.checkNotNull(updatedGte, "updatedGte");
            this.updatedGte = updatedGte;
            return this;
        }


        /**
         * The user/employee ID to filter by (reference to HrisEmployee)
         */
        public Builder userId(String userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = Optional.ofNullable(userId);
            return this;
        }

        /**
         * The user/employee ID to filter by (reference to HrisEmployee)
         */
        public Builder userId(Optional<String> userId) {
            Utils.checkNotNull(userId, "userId");
            this.userId = userId;
            return this;
        }


        /**
         * The user/employee ID to filter by
         */
        public Builder userMentionedId(String userMentionedId) {
            Utils.checkNotNull(userMentionedId, "userMentionedId");
            this.userMentionedId = Optional.ofNullable(userMentionedId);
            return this;
        }

        /**
         * The user/employee ID to filter by
         */
        public Builder userMentionedId(Optional<String> userMentionedId) {
            Utils.checkNotNull(userMentionedId, "userMentionedId");
            this.userMentionedId = userMentionedId;
            return this;
        }

        public ListMessagingMessagesRequest build() {

            return new ListMessagingMessagesRequest(
                channelId, connectionId, endLt,
                expand, fields, limit,
                offset, order, parentId,
                query, raw, sort,
                startGte, type, updatedGte,
                userId, userMentionedId);
        }

    }
}
