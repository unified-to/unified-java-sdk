/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package to.unified.unified_java_sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import to.unified.unified_java_sdk.utils.Utils;

public class CalendarEventRecurrence {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("count")
    private Optional<Double> count;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("end_at")
    private Optional<OffsetDateTime> endAt;

    /**
     * dates to exclude from the recurrence, defaults to undefined (no exclusions)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("excluded_dates")
    private Optional<? extends List<String>> excludedDates;

    @JsonProperty("frequency")
    private CalendarEventRecurrenceFrequency frequency;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("interval")
    private Optional<Double> interval;

    /**
     * days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("on_days")
    private Optional<? extends List<PropertyCalendarEventRecurrenceOnDays>> onDays;

    /**
     * days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("on_month_days")
    private Optional<? extends List<Double>> onMonthDays;

    /**
     * months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("on_months")
    private Optional<? extends List<Double>> onMonths;

    @JsonCreator
    public CalendarEventRecurrence(
            @JsonProperty("count") Optional<Double> count,
            @JsonProperty("end_at") Optional<OffsetDateTime> endAt,
            @JsonProperty("excluded_dates") Optional<? extends List<String>> excludedDates,
            @JsonProperty("frequency") CalendarEventRecurrenceFrequency frequency,
            @JsonProperty("interval") Optional<Double> interval,
            @JsonProperty("on_days") Optional<? extends List<PropertyCalendarEventRecurrenceOnDays>> onDays,
            @JsonProperty("on_month_days") Optional<? extends List<Double>> onMonthDays,
            @JsonProperty("on_months") Optional<? extends List<Double>> onMonths) {
        Utils.checkNotNull(count, "count");
        Utils.checkNotNull(endAt, "endAt");
        Utils.checkNotNull(excludedDates, "excludedDates");
        Utils.checkNotNull(frequency, "frequency");
        Utils.checkNotNull(interval, "interval");
        Utils.checkNotNull(onDays, "onDays");
        Utils.checkNotNull(onMonthDays, "onMonthDays");
        Utils.checkNotNull(onMonths, "onMonths");
        this.count = count;
        this.endAt = endAt;
        this.excludedDates = excludedDates;
        this.frequency = frequency;
        this.interval = interval;
        this.onDays = onDays;
        this.onMonthDays = onMonthDays;
        this.onMonths = onMonths;
    }
    
    public CalendarEventRecurrence(
            CalendarEventRecurrenceFrequency frequency) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), frequency, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty());
    }

    @JsonIgnore
    public Optional<Double> count() {
        return count;
    }

    @JsonIgnore
    public Optional<OffsetDateTime> endAt() {
        return endAt;
    }

    /**
     * dates to exclude from the recurrence, defaults to undefined (no exclusions)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> excludedDates() {
        return (Optional<List<String>>) excludedDates;
    }

    @JsonIgnore
    public CalendarEventRecurrenceFrequency frequency() {
        return frequency;
    }

    @JsonIgnore
    public Optional<Double> interval() {
        return interval;
    }

    /**
     * days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PropertyCalendarEventRecurrenceOnDays>> onDays() {
        return (Optional<List<PropertyCalendarEventRecurrenceOnDays>>) onDays;
    }

    /**
     * days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Double>> onMonthDays() {
        return (Optional<List<Double>>) onMonthDays;
    }

    /**
     * months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Double>> onMonths() {
        return (Optional<List<Double>>) onMonths;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    public CalendarEventRecurrence withCount(double count) {
        Utils.checkNotNull(count, "count");
        this.count = Optional.ofNullable(count);
        return this;
    }

    public CalendarEventRecurrence withCount(Optional<Double> count) {
        Utils.checkNotNull(count, "count");
        this.count = count;
        return this;
    }

    public CalendarEventRecurrence withEndAt(OffsetDateTime endAt) {
        Utils.checkNotNull(endAt, "endAt");
        this.endAt = Optional.ofNullable(endAt);
        return this;
    }

    public CalendarEventRecurrence withEndAt(Optional<OffsetDateTime> endAt) {
        Utils.checkNotNull(endAt, "endAt");
        this.endAt = endAt;
        return this;
    }

    /**
     * dates to exclude from the recurrence, defaults to undefined (no exclusions)
     */
    public CalendarEventRecurrence withExcludedDates(List<String> excludedDates) {
        Utils.checkNotNull(excludedDates, "excludedDates");
        this.excludedDates = Optional.ofNullable(excludedDates);
        return this;
    }

    /**
     * dates to exclude from the recurrence, defaults to undefined (no exclusions)
     */
    public CalendarEventRecurrence withExcludedDates(Optional<? extends List<String>> excludedDates) {
        Utils.checkNotNull(excludedDates, "excludedDates");
        this.excludedDates = excludedDates;
        return this;
    }

    public CalendarEventRecurrence withFrequency(CalendarEventRecurrenceFrequency frequency) {
        Utils.checkNotNull(frequency, "frequency");
        this.frequency = frequency;
        return this;
    }

    public CalendarEventRecurrence withInterval(double interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = Optional.ofNullable(interval);
        return this;
    }

    public CalendarEventRecurrence withInterval(Optional<Double> interval) {
        Utils.checkNotNull(interval, "interval");
        this.interval = interval;
        return this;
    }

    /**
     * days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
     */
    public CalendarEventRecurrence withOnDays(List<PropertyCalendarEventRecurrenceOnDays> onDays) {
        Utils.checkNotNull(onDays, "onDays");
        this.onDays = Optional.ofNullable(onDays);
        return this;
    }

    /**
     * days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
     */
    public CalendarEventRecurrence withOnDays(Optional<? extends List<PropertyCalendarEventRecurrenceOnDays>> onDays) {
        Utils.checkNotNull(onDays, "onDays");
        this.onDays = onDays;
        return this;
    }

    /**
     * days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
     */
    public CalendarEventRecurrence withOnMonthDays(List<Double> onMonthDays) {
        Utils.checkNotNull(onMonthDays, "onMonthDays");
        this.onMonthDays = Optional.ofNullable(onMonthDays);
        return this;
    }

    /**
     * days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
     */
    public CalendarEventRecurrence withOnMonthDays(Optional<? extends List<Double>> onMonthDays) {
        Utils.checkNotNull(onMonthDays, "onMonthDays");
        this.onMonthDays = onMonthDays;
        return this;
    }

    /**
     * months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
     */
    public CalendarEventRecurrence withOnMonths(List<Double> onMonths) {
        Utils.checkNotNull(onMonths, "onMonths");
        this.onMonths = Optional.ofNullable(onMonths);
        return this;
    }

    /**
     * months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
     */
    public CalendarEventRecurrence withOnMonths(Optional<? extends List<Double>> onMonths) {
        Utils.checkNotNull(onMonths, "onMonths");
        this.onMonths = onMonths;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CalendarEventRecurrence other = (CalendarEventRecurrence) o;
        return 
            Objects.deepEquals(this.count, other.count) &&
            Objects.deepEquals(this.endAt, other.endAt) &&
            Objects.deepEquals(this.excludedDates, other.excludedDates) &&
            Objects.deepEquals(this.frequency, other.frequency) &&
            Objects.deepEquals(this.interval, other.interval) &&
            Objects.deepEquals(this.onDays, other.onDays) &&
            Objects.deepEquals(this.onMonthDays, other.onMonthDays) &&
            Objects.deepEquals(this.onMonths, other.onMonths);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            count,
            endAt,
            excludedDates,
            frequency,
            interval,
            onDays,
            onMonthDays,
            onMonths);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CalendarEventRecurrence.class,
                "count", count,
                "endAt", endAt,
                "excludedDates", excludedDates,
                "frequency", frequency,
                "interval", interval,
                "onDays", onDays,
                "onMonthDays", onMonthDays,
                "onMonths", onMonths);
    }
    
    public final static class Builder {
 
        private Optional<Double> count = Optional.empty();
 
        private Optional<OffsetDateTime> endAt = Optional.empty();
 
        private Optional<? extends List<String>> excludedDates = Optional.empty();
 
        private CalendarEventRecurrenceFrequency frequency;
 
        private Optional<Double> interval = Optional.empty();
 
        private Optional<? extends List<PropertyCalendarEventRecurrenceOnDays>> onDays = Optional.empty();
 
        private Optional<? extends List<Double>> onMonthDays = Optional.empty();
 
        private Optional<? extends List<Double>> onMonths = Optional.empty();
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder count(double count) {
            Utils.checkNotNull(count, "count");
            this.count = Optional.ofNullable(count);
            return this;
        }

        public Builder count(Optional<Double> count) {
            Utils.checkNotNull(count, "count");
            this.count = count;
            return this;
        }

        public Builder endAt(OffsetDateTime endAt) {
            Utils.checkNotNull(endAt, "endAt");
            this.endAt = Optional.ofNullable(endAt);
            return this;
        }

        public Builder endAt(Optional<OffsetDateTime> endAt) {
            Utils.checkNotNull(endAt, "endAt");
            this.endAt = endAt;
            return this;
        }

        /**
         * dates to exclude from the recurrence, defaults to undefined (no exclusions)
         */
        public Builder excludedDates(List<String> excludedDates) {
            Utils.checkNotNull(excludedDates, "excludedDates");
            this.excludedDates = Optional.ofNullable(excludedDates);
            return this;
        }

        /**
         * dates to exclude from the recurrence, defaults to undefined (no exclusions)
         */
        public Builder excludedDates(Optional<? extends List<String>> excludedDates) {
            Utils.checkNotNull(excludedDates, "excludedDates");
            this.excludedDates = excludedDates;
            return this;
        }

        public Builder frequency(CalendarEventRecurrenceFrequency frequency) {
            Utils.checkNotNull(frequency, "frequency");
            this.frequency = frequency;
            return this;
        }

        public Builder interval(double interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = Optional.ofNullable(interval);
            return this;
        }

        public Builder interval(Optional<Double> interval) {
            Utils.checkNotNull(interval, "interval");
            this.interval = interval;
            return this;
        }

        /**
         * days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
         */
        public Builder onDays(List<PropertyCalendarEventRecurrenceOnDays> onDays) {
            Utils.checkNotNull(onDays, "onDays");
            this.onDays = Optional.ofNullable(onDays);
            return this;
        }

        /**
         * days of the week to repeat on, defaults to undefined (every day), only used if frequency is WEEKLY
         */
        public Builder onDays(Optional<? extends List<PropertyCalendarEventRecurrenceOnDays>> onDays) {
            Utils.checkNotNull(onDays, "onDays");
            this.onDays = onDays;
            return this;
        }

        /**
         * days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
         */
        public Builder onMonthDays(List<Double> onMonthDays) {
            Utils.checkNotNull(onMonthDays, "onMonthDays");
            this.onMonthDays = Optional.ofNullable(onMonthDays);
            return this;
        }

        /**
         * days of the month to repeat on, defaults to undefined (every day), only used if frequency is MONTHLY
         */
        public Builder onMonthDays(Optional<? extends List<Double>> onMonthDays) {
            Utils.checkNotNull(onMonthDays, "onMonthDays");
            this.onMonthDays = onMonthDays;
            return this;
        }

        /**
         * months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
         */
        public Builder onMonths(List<Double> onMonths) {
            Utils.checkNotNull(onMonths, "onMonths");
            this.onMonths = Optional.ofNullable(onMonths);
            return this;
        }

        /**
         * months of the year to repeat on, defaults to undefined (every month), only used if frequency is YEARLY, January is 1
         */
        public Builder onMonths(Optional<? extends List<Double>> onMonths) {
            Utils.checkNotNull(onMonths, "onMonths");
            this.onMonths = onMonths;
            return this;
        }
        
        public CalendarEventRecurrence build() {
            return new CalendarEventRecurrence(
                count,
                endAt,
                excludedDates,
                frequency,
                interval,
                onDays,
                onMonthDays,
                onMonths);
        }
    }
}
