/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package to.unified.unified_java_sdk.models.shared;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import to.unified.unified_java_sdk.utils.Utils;


public class VerificationPackage {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("aliases")
    private Optional<? extends List<String>> aliases;

    /**
     * average processing time in minutes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("average_processing_times")
    private Optional<? extends List<VerificationTime>> averageProcessingTimes;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cost_amount")
    private Optional<Double> costAmount;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private Optional<OffsetDateTime> createdAt;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private Optional<String> currency;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private Optional<String> description;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has_redirect_url")
    private Optional<Boolean> hasRedirectUrl;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has_target_url")
    private Optional<Boolean> hasTargetUrl;


    @JsonProperty("id")
    private String id;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("info_url")
    private Optional<String> infoUrl;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("max_score")
    private Optional<Double> maxScore;


    @JsonProperty("name")
    private String name;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("needs_ip_address")
    private Optional<Boolean> needsIpAddress;

    /**
     * Questions that need to be answered for this verification
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parameters")
    private Optional<? extends List<VerificationParameter>> parameters;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("raw")
    private Optional<? extends Map<String, Object>> raw;

    /**
     * Category (Verification, Validation, Background Check)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tags")
    private Optional<? extends List<String>> tags;


    @JsonProperty("type")
    private VerificationPackageType type;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private Optional<OffsetDateTime> updatedAt;

    @JsonCreator
    public VerificationPackage(
            @JsonProperty("aliases") Optional<? extends List<String>> aliases,
            @JsonProperty("average_processing_times") Optional<? extends List<VerificationTime>> averageProcessingTimes,
            @JsonProperty("cost_amount") Optional<Double> costAmount,
            @JsonProperty("created_at") Optional<OffsetDateTime> createdAt,
            @JsonProperty("currency") Optional<String> currency,
            @JsonProperty("description") Optional<String> description,
            @JsonProperty("has_redirect_url") Optional<Boolean> hasRedirectUrl,
            @JsonProperty("has_target_url") Optional<Boolean> hasTargetUrl,
            @JsonProperty("id") String id,
            @JsonProperty("info_url") Optional<String> infoUrl,
            @JsonProperty("max_score") Optional<Double> maxScore,
            @JsonProperty("name") String name,
            @JsonProperty("needs_ip_address") Optional<Boolean> needsIpAddress,
            @JsonProperty("parameters") Optional<? extends List<VerificationParameter>> parameters,
            @JsonProperty("raw") Optional<? extends Map<String, Object>> raw,
            @JsonProperty("tags") Optional<? extends List<String>> tags,
            @JsonProperty("type") VerificationPackageType type,
            @JsonProperty("updated_at") Optional<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(aliases, "aliases");
        Utils.checkNotNull(averageProcessingTimes, "averageProcessingTimes");
        Utils.checkNotNull(costAmount, "costAmount");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(hasRedirectUrl, "hasRedirectUrl");
        Utils.checkNotNull(hasTargetUrl, "hasTargetUrl");
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(infoUrl, "infoUrl");
        Utils.checkNotNull(maxScore, "maxScore");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(needsIpAddress, "needsIpAddress");
        Utils.checkNotNull(parameters, "parameters");
        Utils.checkNotNull(raw, "raw");
        Utils.checkNotNull(tags, "tags");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.aliases = aliases;
        this.averageProcessingTimes = averageProcessingTimes;
        this.costAmount = costAmount;
        this.createdAt = createdAt;
        this.currency = currency;
        this.description = description;
        this.hasRedirectUrl = hasRedirectUrl;
        this.hasTargetUrl = hasTargetUrl;
        this.id = id;
        this.infoUrl = infoUrl;
        this.maxScore = maxScore;
        this.name = name;
        this.needsIpAddress = needsIpAddress;
        this.parameters = parameters;
        this.raw = raw;
        this.tags = tags;
        this.type = type;
        this.updatedAt = updatedAt;
    }
    
    public VerificationPackage(
            String id,
            String name,
            VerificationPackageType type) {
        this(Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), id,
            Optional.empty(), Optional.empty(), name,
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), type, Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> aliases() {
        return (Optional<List<String>>) aliases;
    }

    /**
     * average processing time in minutes
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<VerificationTime>> averageProcessingTimes() {
        return (Optional<List<VerificationTime>>) averageProcessingTimes;
    }

    @JsonIgnore
    public Optional<Double> costAmount() {
        return costAmount;
    }

    @JsonIgnore
    public Optional<OffsetDateTime> createdAt() {
        return createdAt;
    }

    @JsonIgnore
    public Optional<String> currency() {
        return currency;
    }

    @JsonIgnore
    public Optional<String> description() {
        return description;
    }

    @JsonIgnore
    public Optional<Boolean> hasRedirectUrl() {
        return hasRedirectUrl;
    }

    @JsonIgnore
    public Optional<Boolean> hasTargetUrl() {
        return hasTargetUrl;
    }

    @JsonIgnore
    public String id() {
        return id;
    }

    @JsonIgnore
    public Optional<String> infoUrl() {
        return infoUrl;
    }

    @JsonIgnore
    public Optional<Double> maxScore() {
        return maxScore;
    }

    @JsonIgnore
    public String name() {
        return name;
    }

    @JsonIgnore
    public Optional<Boolean> needsIpAddress() {
        return needsIpAddress;
    }

    /**
     * Questions that need to be answered for this verification
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<VerificationParameter>> parameters() {
        return (Optional<List<VerificationParameter>>) parameters;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Map<String, Object>> raw() {
        return (Optional<Map<String, Object>>) raw;
    }

    /**
     * Category (Verification, Validation, Background Check)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> tags() {
        return (Optional<List<String>>) tags;
    }

    @JsonIgnore
    public VerificationPackageType type() {
        return type;
    }

    @JsonIgnore
    public Optional<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    public static Builder builder() {
        return new Builder();
    }


    public VerificationPackage withAliases(List<String> aliases) {
        Utils.checkNotNull(aliases, "aliases");
        this.aliases = Optional.ofNullable(aliases);
        return this;
    }


    public VerificationPackage withAliases(Optional<? extends List<String>> aliases) {
        Utils.checkNotNull(aliases, "aliases");
        this.aliases = aliases;
        return this;
    }

    /**
     * average processing time in minutes
     */
    public VerificationPackage withAverageProcessingTimes(List<VerificationTime> averageProcessingTimes) {
        Utils.checkNotNull(averageProcessingTimes, "averageProcessingTimes");
        this.averageProcessingTimes = Optional.ofNullable(averageProcessingTimes);
        return this;
    }


    /**
     * average processing time in minutes
     */
    public VerificationPackage withAverageProcessingTimes(Optional<? extends List<VerificationTime>> averageProcessingTimes) {
        Utils.checkNotNull(averageProcessingTimes, "averageProcessingTimes");
        this.averageProcessingTimes = averageProcessingTimes;
        return this;
    }

    public VerificationPackage withCostAmount(double costAmount) {
        Utils.checkNotNull(costAmount, "costAmount");
        this.costAmount = Optional.ofNullable(costAmount);
        return this;
    }


    public VerificationPackage withCostAmount(Optional<Double> costAmount) {
        Utils.checkNotNull(costAmount, "costAmount");
        this.costAmount = costAmount;
        return this;
    }

    public VerificationPackage withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }


    public VerificationPackage withCreatedAt(Optional<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    public VerificationPackage withCurrency(String currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = Optional.ofNullable(currency);
        return this;
    }


    public VerificationPackage withCurrency(Optional<String> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    public VerificationPackage withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = Optional.ofNullable(description);
        return this;
    }


    public VerificationPackage withDescription(Optional<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    public VerificationPackage withHasRedirectUrl(boolean hasRedirectUrl) {
        Utils.checkNotNull(hasRedirectUrl, "hasRedirectUrl");
        this.hasRedirectUrl = Optional.ofNullable(hasRedirectUrl);
        return this;
    }


    public VerificationPackage withHasRedirectUrl(Optional<Boolean> hasRedirectUrl) {
        Utils.checkNotNull(hasRedirectUrl, "hasRedirectUrl");
        this.hasRedirectUrl = hasRedirectUrl;
        return this;
    }

    public VerificationPackage withHasTargetUrl(boolean hasTargetUrl) {
        Utils.checkNotNull(hasTargetUrl, "hasTargetUrl");
        this.hasTargetUrl = Optional.ofNullable(hasTargetUrl);
        return this;
    }


    public VerificationPackage withHasTargetUrl(Optional<Boolean> hasTargetUrl) {
        Utils.checkNotNull(hasTargetUrl, "hasTargetUrl");
        this.hasTargetUrl = hasTargetUrl;
        return this;
    }

    public VerificationPackage withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    public VerificationPackage withInfoUrl(String infoUrl) {
        Utils.checkNotNull(infoUrl, "infoUrl");
        this.infoUrl = Optional.ofNullable(infoUrl);
        return this;
    }


    public VerificationPackage withInfoUrl(Optional<String> infoUrl) {
        Utils.checkNotNull(infoUrl, "infoUrl");
        this.infoUrl = infoUrl;
        return this;
    }

    public VerificationPackage withMaxScore(double maxScore) {
        Utils.checkNotNull(maxScore, "maxScore");
        this.maxScore = Optional.ofNullable(maxScore);
        return this;
    }


    public VerificationPackage withMaxScore(Optional<Double> maxScore) {
        Utils.checkNotNull(maxScore, "maxScore");
        this.maxScore = maxScore;
        return this;
    }

    public VerificationPackage withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    public VerificationPackage withNeedsIpAddress(boolean needsIpAddress) {
        Utils.checkNotNull(needsIpAddress, "needsIpAddress");
        this.needsIpAddress = Optional.ofNullable(needsIpAddress);
        return this;
    }


    public VerificationPackage withNeedsIpAddress(Optional<Boolean> needsIpAddress) {
        Utils.checkNotNull(needsIpAddress, "needsIpAddress");
        this.needsIpAddress = needsIpAddress;
        return this;
    }

    /**
     * Questions that need to be answered for this verification
     */
    public VerificationPackage withParameters(List<VerificationParameter> parameters) {
        Utils.checkNotNull(parameters, "parameters");
        this.parameters = Optional.ofNullable(parameters);
        return this;
    }


    /**
     * Questions that need to be answered for this verification
     */
    public VerificationPackage withParameters(Optional<? extends List<VerificationParameter>> parameters) {
        Utils.checkNotNull(parameters, "parameters");
        this.parameters = parameters;
        return this;
    }

    public VerificationPackage withRaw(Map<String, Object> raw) {
        Utils.checkNotNull(raw, "raw");
        this.raw = Optional.ofNullable(raw);
        return this;
    }


    public VerificationPackage withRaw(Optional<? extends Map<String, Object>> raw) {
        Utils.checkNotNull(raw, "raw");
        this.raw = raw;
        return this;
    }

    /**
     * Category (Verification, Validation, Background Check)
     */
    public VerificationPackage withTags(List<String> tags) {
        Utils.checkNotNull(tags, "tags");
        this.tags = Optional.ofNullable(tags);
        return this;
    }


    /**
     * Category (Verification, Validation, Background Check)
     */
    public VerificationPackage withTags(Optional<? extends List<String>> tags) {
        Utils.checkNotNull(tags, "tags");
        this.tags = tags;
        return this;
    }

    public VerificationPackage withType(VerificationPackageType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public VerificationPackage withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = Optional.ofNullable(updatedAt);
        return this;
    }


    public VerificationPackage withUpdatedAt(Optional<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        VerificationPackage other = (VerificationPackage) o;
        return 
            Utils.enhancedDeepEquals(this.aliases, other.aliases) &&
            Utils.enhancedDeepEquals(this.averageProcessingTimes, other.averageProcessingTimes) &&
            Utils.enhancedDeepEquals(this.costAmount, other.costAmount) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.currency, other.currency) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.hasRedirectUrl, other.hasRedirectUrl) &&
            Utils.enhancedDeepEquals(this.hasTargetUrl, other.hasTargetUrl) &&
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.infoUrl, other.infoUrl) &&
            Utils.enhancedDeepEquals(this.maxScore, other.maxScore) &&
            Utils.enhancedDeepEquals(this.name, other.name) &&
            Utils.enhancedDeepEquals(this.needsIpAddress, other.needsIpAddress) &&
            Utils.enhancedDeepEquals(this.parameters, other.parameters) &&
            Utils.enhancedDeepEquals(this.raw, other.raw) &&
            Utils.enhancedDeepEquals(this.tags, other.tags) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            aliases, averageProcessingTimes, costAmount,
            createdAt, currency, description,
            hasRedirectUrl, hasTargetUrl, id,
            infoUrl, maxScore, name,
            needsIpAddress, parameters, raw,
            tags, type, updatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(VerificationPackage.class,
                "aliases", aliases,
                "averageProcessingTimes", averageProcessingTimes,
                "costAmount", costAmount,
                "createdAt", createdAt,
                "currency", currency,
                "description", description,
                "hasRedirectUrl", hasRedirectUrl,
                "hasTargetUrl", hasTargetUrl,
                "id", id,
                "infoUrl", infoUrl,
                "maxScore", maxScore,
                "name", name,
                "needsIpAddress", needsIpAddress,
                "parameters", parameters,
                "raw", raw,
                "tags", tags,
                "type", type,
                "updatedAt", updatedAt);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends List<String>> aliases = Optional.empty();

        private Optional<? extends List<VerificationTime>> averageProcessingTimes = Optional.empty();

        private Optional<Double> costAmount = Optional.empty();

        private Optional<OffsetDateTime> createdAt = Optional.empty();

        private Optional<String> currency = Optional.empty();

        private Optional<String> description = Optional.empty();

        private Optional<Boolean> hasRedirectUrl = Optional.empty();

        private Optional<Boolean> hasTargetUrl = Optional.empty();

        private String id;

        private Optional<String> infoUrl = Optional.empty();

        private Optional<Double> maxScore = Optional.empty();

        private String name;

        private Optional<Boolean> needsIpAddress = Optional.empty();

        private Optional<? extends List<VerificationParameter>> parameters = Optional.empty();

        private Optional<? extends Map<String, Object>> raw = Optional.empty();

        private Optional<? extends List<String>> tags = Optional.empty();

        private VerificationPackageType type;

        private Optional<OffsetDateTime> updatedAt = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        public Builder aliases(List<String> aliases) {
            Utils.checkNotNull(aliases, "aliases");
            this.aliases = Optional.ofNullable(aliases);
            return this;
        }

        public Builder aliases(Optional<? extends List<String>> aliases) {
            Utils.checkNotNull(aliases, "aliases");
            this.aliases = aliases;
            return this;
        }


        /**
         * average processing time in minutes
         */
        public Builder averageProcessingTimes(List<VerificationTime> averageProcessingTimes) {
            Utils.checkNotNull(averageProcessingTimes, "averageProcessingTimes");
            this.averageProcessingTimes = Optional.ofNullable(averageProcessingTimes);
            return this;
        }

        /**
         * average processing time in minutes
         */
        public Builder averageProcessingTimes(Optional<? extends List<VerificationTime>> averageProcessingTimes) {
            Utils.checkNotNull(averageProcessingTimes, "averageProcessingTimes");
            this.averageProcessingTimes = averageProcessingTimes;
            return this;
        }


        public Builder costAmount(double costAmount) {
            Utils.checkNotNull(costAmount, "costAmount");
            this.costAmount = Optional.ofNullable(costAmount);
            return this;
        }

        public Builder costAmount(Optional<Double> costAmount) {
            Utils.checkNotNull(costAmount, "costAmount");
            this.costAmount = costAmount;
            return this;
        }


        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        public Builder createdAt(Optional<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        public Builder currency(String currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = Optional.ofNullable(currency);
            return this;
        }

        public Builder currency(Optional<String> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }


        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = Optional.ofNullable(description);
            return this;
        }

        public Builder description(Optional<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }


        public Builder hasRedirectUrl(boolean hasRedirectUrl) {
            Utils.checkNotNull(hasRedirectUrl, "hasRedirectUrl");
            this.hasRedirectUrl = Optional.ofNullable(hasRedirectUrl);
            return this;
        }

        public Builder hasRedirectUrl(Optional<Boolean> hasRedirectUrl) {
            Utils.checkNotNull(hasRedirectUrl, "hasRedirectUrl");
            this.hasRedirectUrl = hasRedirectUrl;
            return this;
        }


        public Builder hasTargetUrl(boolean hasTargetUrl) {
            Utils.checkNotNull(hasTargetUrl, "hasTargetUrl");
            this.hasTargetUrl = Optional.ofNullable(hasTargetUrl);
            return this;
        }

        public Builder hasTargetUrl(Optional<Boolean> hasTargetUrl) {
            Utils.checkNotNull(hasTargetUrl, "hasTargetUrl");
            this.hasTargetUrl = hasTargetUrl;
            return this;
        }


        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        public Builder infoUrl(String infoUrl) {
            Utils.checkNotNull(infoUrl, "infoUrl");
            this.infoUrl = Optional.ofNullable(infoUrl);
            return this;
        }

        public Builder infoUrl(Optional<String> infoUrl) {
            Utils.checkNotNull(infoUrl, "infoUrl");
            this.infoUrl = infoUrl;
            return this;
        }


        public Builder maxScore(double maxScore) {
            Utils.checkNotNull(maxScore, "maxScore");
            this.maxScore = Optional.ofNullable(maxScore);
            return this;
        }

        public Builder maxScore(Optional<Double> maxScore) {
            Utils.checkNotNull(maxScore, "maxScore");
            this.maxScore = maxScore;
            return this;
        }


        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }


        public Builder needsIpAddress(boolean needsIpAddress) {
            Utils.checkNotNull(needsIpAddress, "needsIpAddress");
            this.needsIpAddress = Optional.ofNullable(needsIpAddress);
            return this;
        }

        public Builder needsIpAddress(Optional<Boolean> needsIpAddress) {
            Utils.checkNotNull(needsIpAddress, "needsIpAddress");
            this.needsIpAddress = needsIpAddress;
            return this;
        }


        /**
         * Questions that need to be answered for this verification
         */
        public Builder parameters(List<VerificationParameter> parameters) {
            Utils.checkNotNull(parameters, "parameters");
            this.parameters = Optional.ofNullable(parameters);
            return this;
        }

        /**
         * Questions that need to be answered for this verification
         */
        public Builder parameters(Optional<? extends List<VerificationParameter>> parameters) {
            Utils.checkNotNull(parameters, "parameters");
            this.parameters = parameters;
            return this;
        }


        public Builder raw(Map<String, Object> raw) {
            Utils.checkNotNull(raw, "raw");
            this.raw = Optional.ofNullable(raw);
            return this;
        }

        public Builder raw(Optional<? extends Map<String, Object>> raw) {
            Utils.checkNotNull(raw, "raw");
            this.raw = raw;
            return this;
        }


        /**
         * Category (Verification, Validation, Background Check)
         */
        public Builder tags(List<String> tags) {
            Utils.checkNotNull(tags, "tags");
            this.tags = Optional.ofNullable(tags);
            return this;
        }

        /**
         * Category (Verification, Validation, Background Check)
         */
        public Builder tags(Optional<? extends List<String>> tags) {
            Utils.checkNotNull(tags, "tags");
            this.tags = tags;
            return this;
        }


        public Builder type(VerificationPackageType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        public Builder updatedAt(Optional<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        public VerificationPackage build() {

            return new VerificationPackage(
                aliases, averageProcessingTimes, costAmount,
                createdAt, currency, description,
                hasRedirectUrl, hasTargetUrl, id,
                infoUrl, maxScore, name,
                needsIpAddress, parameters, raw,
                tags, type, updatedAt);
        }

    }
}
